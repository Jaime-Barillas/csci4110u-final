#ifndef CSCI_4110U_GL_ERRORS_H
#define CSCI_4110U_GL_ERRORS_H

#include <map>
#include <string>
#include <glad/gl.h>

static std::map<GLenum, std::string> gl_error_codes{
  {GL_NO_ERROR, "GL_NO_ERROR"},
  {GL_INVALID_ENUM, "GL_INVALID_ENUM"},
  {GL_INVALID_VALUE, "GL_INVALID_VALUE"},
  {GL_INVALID_OPERATION, "GL_INVALID_OPERATION"},
  {GL_INVALID_FRAMEBUFFER_OPERATION, "GL_INVALID_FRAMEBUFFER_OPERATION"},
  {GL_OUT_OF_MEMORY, "GL_OUT_OF_MEMORY"},
  {GL_STACK_UNDERFLOW, "GL_STACK_UNDERFLOW"},
  {GL_STACK_OVERFLOW, "GL_STACK_OVERFLOW"},
};

static std::map<std::string, std::map<GLenum, std::string>> gl_errors{
  {"unknown", {{GL_NO_ERROR, "Unknown error!"}}},
  {"glAttachShader", {
    {GL_INVALID_VALUE, "Either `program` or `shader` is not value generated by OpenGL!"},
    {GL_INVALID_OPERATION, "Either: `program` is not a program object, `shader` is not a shader object, or `shader` is already attached to `program`!"},
  }},
  {"glBindBuffer", {
    {GL_INVALID_ENUM, "`target` is not one of the allowable values!"},
    {GL_INVALID_VALUE, "`buffer` is not a name generated from a call to glGenBuffers!"},
  }},
  {"glBindVertexArray", {
    {GL_INVALID_OPERATION, "`array` is not zero or the name of a VAO!"},
  }},
  {"glBufferData", {
    {GL_INVALID_ENUM, "Either: `target` is not one of the accepted targets or `usage` is not one of the accepted values!"},
    {GL_INVALID_VALUE, "`size` is negative!"},
    {GL_INVALID_OPERATION, "Either: The reserved buffer object name 0 is bound to `target` or the GL_BUFFER_IMMUTABLE_STORAGE flag of the buffer object is set to GL_TRUE!"},
    {GL_OUT_OF_MEMORY, "OpenGL is unable to create the data store with the specified `size`!"},
  }},
  {"glClear", {
    {GL_INVALID_VALUE, "`mask` set to unknown bit!"},
  }},
  {"glCompileShader", {
    {GL_INVALID_VALUE, "`shader` is not a value generated by OpenGL!"},
    {GL_INVALID_OPERATION, "`shader` is not a shader object!"},
  }},
  /* glCreateProgram does not set an error, instead returns 0.
  {"glCreateProgram", {
    {}
  }},
  */
  {"glCreateShader", {
    {GL_INVALID_ENUM, "`shaderType` is not a valid value!"},
  }},
  {"glDeleteProgram", {
    {GL_INVALID_VALUE, "`program` is not a value generated by OpenGL!"},
  }},
  {"glDeleteShader", {
    {GL_INVALID_VALUE, "`shader` is not a value generated by OpenGL!"},
  }},
  {"glDrawArrays", {
    {GL_INVALID_ENUM, "`mode` is not an valid value!"},
    {GL_INVALID_VALUE, "`count` is negative!"},
    {GL_INVALID_OPERATION, "Either: A non-zero buffer object is bound to an enabled array and its data store is currently mapped or a geometry shader is active and `mode` is incompatible with its input type!"},
  }},
  {"glEnableVertexAttribArray", {
    {GL_INVALID_VALUE, "`index` is greater than or equal to GL_MAX_VERTEX_ATTRIBS!"},
    {GL_INVALID_OPERATION, "Either: No VAO is bound or `vaobj` is not the name of an existing VAO!"},
  }},
  {"glGenBuffers", {
    {GL_INVALID_VALUE, "`n` is negative!"},
  }},
  {"glGenVertexArrays", {
    {GL_INVALID_VALUE, "`n` is negative!"},
  }},
  {"glGetProgramInfoLog", {
    {GL_INVALID_VALUE, "Either: `program` is not a value generated by OpenGL or `maxLength` is less than zero!"},
    {GL_INVALID_OPERATION, "`program` is not a program object!"},
  }},
  {"glGetProgramiv", {
    {GL_INVALID_VALUE, "`program` is not a value generated by OpenGL!"},
    {GL_INVALID_OPERATION, "`program` is not a program object!"},
    {GL_INVALID_ENUM, "`pname` is not an accepted value!"},
  }},
  {"glGetShaderInfoLog", {
    {GL_INVALID_VALUE, "Either: `shader` is not a value generated by OpenGL or `maxLength` is less than zero!"},
    {GL_INVALID_OPERATION, "`shader` is not a shader object!"},
  }},
  {"glGetProgramiv", {
    {GL_INVALID_VALUE, "`shader` is not a value generated by OpenGL!"},
    {GL_INVALID_OPERATION, "`shader` is not a shader object!"},
    {GL_INVALID_ENUM, "`pname` is not an accepted value!"},
  }},
  {"glLinkProgram", {
    {GL_INVALID_VALUE, "`program` is not a value generated by OpenGL!"},
    {GL_INVALID_OPERATION, "Either: `program is not a program object or `program` is currently active and transform feedback mode is enabled!`"},
  }},
  {"glShaderSource", {
    {GL_INVALID_VALUE, "Either: `shader` is not a value generated by OpenGL or `count` is less than 0!"},
    {GL_INVALID_OPERATION, "`shader` is not a shader object!"},
  }},
  {"glUseProgram", {
    {GL_INVALID_VALUE, "Either: `program` is not a value generated by OpenGL nor 0!"},
    {GL_INVALID_OPERATION, "Either: `program` is not a program object, `program` could not be made part of the current state, or transform feedback mode is enabled!"},
  }},
  {"glVertexAttribPointer", {
    {GL_INVALID_VALUE, "Either: `index` is greater or equal to GL_MAX_VERTEX_ATTRIBS, `size` is not 1, 2, 3, 4, or GL_BGRA, or `stride` is negative!"},
    {GL_INVALID_ENUM, "`type` is not an accepted value!"},
    {GL_INVALID_OPERATION, "`size` and `type` values mismatch, `size` is GL_BGRA and `normalized` is GL_FALSE, or zero is bound to the buffer object binding point and `pointer` is not NULL!"},
  }},
};

const std::string &getGLErrorCodeString(GLenum error_code) {
  return gl_error_codes[error_code];
}

const std::string &getGLErrorString(const char *name, GLenum error_code) {
  auto msg_map = gl_errors.find(name);
  if (msg_map == gl_errors.end()) return gl_errors["unknown"][GL_NO_ERROR];

  auto msg = msg_map->second.find(error_code);
  if (msg == msg_map->second.end()) return gl_errors["unknown"][GL_NO_ERROR];

  return msg->second;
}

#endif
